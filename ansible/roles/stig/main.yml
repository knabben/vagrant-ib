---
###############################################################################
#
# Ansible remediation role for profile stig
# Profile Title:  Canonical Ubuntu 20.04 LTS Security Technical Implementation Guide (STIG) V1R1
# Profile Description:
# This Security Technical Implementation Guide is published as a tool to
# improve the security of Department of Defense (DoD) information systems.
# The requirements are derived from the National Institute of Standards and
# Technology (NIST) 800-53 and related documents.
#
# Benchmark ID:  UBUNTU_20-04
# Benchmark Version:  0.1.58
#
# XCCDF Version:  1.1
#
# This file was generated by OpenSCAP 1.2.16 using:
# 	$ oscap xccdf generate fix --profile stig --template urn:xccdf:fix:script:ansible sds.xml 
#
# This script is generated from an OpenSCAP profile without preliminary evaluation.
# It attempts to fix every selected rule, even if the system is already compliant.
#
# How to apply this remediation role:
# $ ansible-playbook -i "192.168.1.155," playbook.yml
# $ ansible-playbook -i inventory.ini playbook.yml
#
###############################################################################


 - hosts: all
   vars:
      login_banner_text: !!str ^(You[\s\n]+are[\s\n]+accessing[\s\n]+a[\s\n]+U\.S\.[\s\n]+Government[\s\n]+\(USG\)[\s\n]+Information[\s\n]+System[\s\n]+\(IS\)[\s\n]+that[\s\n]+is[\s\n]+provided[\s\n]+for[\s\n]+USG\-authorized[\s\n]+use[\s\n]+only\.[\s\n]+By[\s\n]+using[\s\n]+this[\s\n]+IS[\s\n]+\(which[\s\n]+includes[\s\n]+any[\s\n]+device[\s\n]+attached[\s\n]+to[\s\n]+this[\s\n]+IS\)\,[\s\n]+you[\s\n]+consent[\s\n]+to[\s\n]+the[\s\n]+following[\s\n]+conditions\:(?:[\n]+|(?:\\n)+)\-The[\s\n]+USG[\s\n]+routinely[\s\n]+intercepts[\s\n]+and[\s\n]+monitors[\s\n]+communications[\s\n]+on[\s\n]+this[\s\n]+IS[\s\n]+for[\s\n]+purposes[\s\n]+including\,[\s\n]+but[\s\n]+not[\s\n]+limited[\s\n]+to\,[\s\n]+penetration[\s\n]+testing\,[\s\n]+COMSEC[\s\n]+monitoring\,[\s\n]+network[\s\n]+operations[\s\n]+and[\s\n]+defense\,[\s\n]+personnel[\s\n]+misconduct[\s\n]+\(PM\)\,[\s\n]+law[\s\n]+enforcement[\s\n]+\(LE\)\,[\s\n]+and[\s\n]+counterintelligence[\s\n]+\(CI\)[\s\n]+investigations\.(?:[\n]+|(?:\\n)+)\-At[\s\n]+any[\s\n]+time\,[\s\n]+the[\s\n]+USG[\s\n]+may[\s\n]+inspect[\s\n]+and[\s\n]+seize[\s\n]+data[\s\n]+stored[\s\n]+on[\s\n]+this[\s\n]+IS\.(?:[\n]+|(?:\\n)+)\-Communications[\s\n]+using\,[\s\n]+or[\s\n]+data[\s\n]+stored[\s\n]+on\,[\s\n]+this[\s\n]+IS[\s\n]+are[\s\n]+not[\s\n]+private\,[\s\n]+are[\s\n]+subject[\s\n]+to[\s\n]+routine[\s\n]+monitoring\,[\s\n]+interception\,[\s\n]+and[\s\n]+search\,[\s\n]+and[\s\n]+may[\s\n]+be[\s\n]+disclosed[\s\n]+or[\s\n]+used[\s\n]+for[\s\n]+any[\s\n]+USG\-authorized[\s\n]+purpose\.(?:[\n]+|(?:\\n)+)\-This[\s\n]+IS[\s\n]+includes[\s\n]+security[\s\n]+measures[\s\n]+\(e\.g\.\,[\s\n]+authentication[\s\n]+and[\s\n]+access[\s\n]+controls\)[\s\n]+to[\s\n]+protect[\s\n]+USG[\s\n]+interests\-\-not[\s\n]+for[\s\n]+your[\s\n]+personal[\s\n]+benefit[\s\n]+or[\s\n]+privacy\.(?:[\n]+|(?:\\n)+)\-Notwithstanding[\s\n]+the[\s\n]+above\,[\s\n]+using[\s\n]+this[\s\n]+IS[\s\n]+does[\s\n]+not[\s\n]+constitute[\s\n]+consent[\s\n]+to[\s\n]+PM\,[\s\n]+LE[\s\n]+or[\s\n]+CI[\s\n]+investigative[\s\n]+searching[\s\n]+or[\s\n]+monitoring[\s\n]+of[\s\n]+the[\s\n]+content[\s\n]+of[\s\n]+privileged[\s\n]+communications\,[\s\n]+or[\s\n]+work[\s\n]+product\,[\s\n]+related[\s\n]+to[\s\n]+personal[\s\n]+representation[\s\n]+or[\s\n]+services[\s\n]+by[\s\n]+attorneys\,[\s\n]+psychotherapists\,[\s\n]+or[\s\n]+clergy\,[\s\n]+and[\s\n]+their[\s\n]+assistants\.[\s\n]+Such[\s\n]+communications[\s\n]+and[\s\n]+work[\s\n]+product[\s\n]+are[\s\n]+private[\s\n]+and[\s\n]+confidential\.[\s\n]+See[\s\n]+User[\s\n]+Agreement[\s\n]+for[\s\n]+details\.|I've[\s\n]+read[\s\n]+\&[\s\n]+consent[\s\n]+to[\s\n]+terms[\s\n]+in[\s\n]+IS[\s\n]+user[\s\n]+agreem't\.)$
      var_password_pam_unix_remember: !!str 5
      var_password_pam_dcredit: !!str -1
      var_password_pam_dictcheck: !!str 1
      var_password_pam_difok: !!str 8
      var_password_pam_lcredit: !!str -1
      var_password_pam_minlen: !!str 15
      var_password_pam_ocredit: !!str -1
      var_password_pam_retry: !!str 3
      var_password_pam_ucredit: !!str -1
      var_password_hashing_algorithm: !!str SHA512
      var_account_disable_post_pw_expiration: !!str 35
      var_accounts_maximum_age_login_defs: !!str 60
      var_accounts_minimum_age_login_defs: !!str 1
      var_accounts_max_concurrent_login_sessions: !!str 10
      var_accounts_tmout: !!str 600
      var_accounts_user_umask: !!str 077
      var_audispd_remote_server: !!str logcollector
      var_auditd_disk_full_action: !!str halt
      var_auditd_action_mail_acct: !!str root
      var_auditd_space_left: !!str 25%
      var_auditd_space_left_action: !!str email
      sysctl_net_ipv4_tcp_syncookies_value: !!str 1
      var_firewall_package: !!str ufw
      var_firewall_package: !!str ufw
      var_time_synchronization_daemon: !!str chrony
      var_time_service_set_maxpoll: !!str 17
      sshd_idle_timeout_value: !!str 600
      var_sshd_set_keepalive: !!str 1
   tasks:
    - name: Ensure aide is installed
      package:
        name: aide
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.10.1.3
        - DISA-STIG-UBTU-20-010450
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-11.5
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_aide_installed
    
    - name: Ensure aide is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010205
        - NIST-800-53-AU-9(3)
        - NIST-800-53-AU-9(3).1
        - aide_check_audit_tools
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set audit_tools fact
      set_fact:
        audit_tools:
          - /usr/sbin/audispd
          - /usr/sbin/auditctl
          - /usr/sbin/auditd
          - /usr/sbin/augenrules
          - /usr/sbin/aureport
          - /usr/sbin/ausearch
          - /usr/sbin/autrace
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010205
        - NIST-800-53-AU-9(3)
        - NIST-800-53-AU-9(3).1
        - aide_check_audit_tools
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure existing AIDE configuration for audit tools are correct
      lineinfile:
        path: /etc/aide.conf
        regexp: ^{{ item }}\s
        line: '{{ item }} p+i+n+u+g+s+b+acl+selinux+xattrs+sha512'
      with_items: '{{ audit_tools }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010205
        - NIST-800-53-AU-9(3)
        - NIST-800-53-AU-9(3).1
        - aide_check_audit_tools
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Configure AIDE to properly protect audit tools
      lineinfile:
        path: /etc/aide.conf
        line: '{{ item }} p+i+n+u+g+s+b+acl+selinux+xattrs+sha512'
      with_items: '{{ audit_tools }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010205
        - NIST-800-53-AU-9(3)
        - NIST-800-53-AU-9(3).1
        - aide_check_audit_tools
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure AIDE is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.10.1.3
        - DISA-STIG-UBTU-20-010074
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SI-7
        - NIST-800-53-SI-7(1)
        - PCI-DSS-Req-11.5
        - aide_periodic_cron_checking
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Configure Periodic Execution of AIDE
      cron:
        name: run AIDE check
        minute: 5
        hour: 4
        weekday: 0
        user: root
        job: /usr/sbin/aide --check
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.10.1.3
        - DISA-STIG-UBTU-20-010074
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SI-7
        - NIST-800-53-SI-7(1)
        - PCI-DSS-Req-11.5
        - aide_periodic_cron_checking
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure mfetp is installed
      package:
        name: mfetp
        state: present
      tags:
        - DISA-STIG-UBTU-20-010415
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_mfetp_installed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Dconf Update
      command: dconf update
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - ansible_distribution == 'SLES'
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Enable GNOME3 Screensaver Lock After Idle Period
      ini_file:
        dest: /etc/dconf/db/local.d/00-security-settings
        section: org/gnome/desktop/screensaver
        option: lock-enabled
        value: 'true'
        create: true
        no_extra_spaces: true
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Prevent user modification of GNOME lock-enabled
      lineinfile:
        path: /etc/dconf/db/local.d/locks/00-security-settings-lock
        regexp: ^/org/gnome/desktop/screensaver/lock-enabled$
        line: /org/gnome/desktop/screensaver/lock-enabled
        create: true
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Check GNOME3 screenserver disable-lock-screen false
      command: gsettings get org.gnome.desktop.lockdown disable-lock-screen
      register: cmd_out
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - ansible_distribution == 'SLES'
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Update GNOME3 screenserver disable-lock-screen false
      command: gsettings set org.gnome.desktop.lockdown disable-lock-screen false
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - ansible_distribution == 'SLES'
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Dconf Update
      command: dconf update
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.5
        - DISA-STIG-UBTU-20-010004
        - NIST-800-171-3.1.10
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-8.1.8
        - dconf_gnome_screensaver_lock_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010459
        - NIST-800-171-3.1.2
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(b)
        - dconf_gnome_disable_ctrlaltdel_reboot
        - high_severity
        - low_complexity
        - medium_disruption
        - no_reboot_needed
        - unknown_strategy
    
    - name: Disable Ctrl-Alt-Del Reboot Key Sequence in GNOME3
      ini_file:
        dest: /etc/dconf/db/local.d/00-security-settings
        section: org/gnome/settings-daemon/plugins/media-keys
        option: logout
        value: ''''''
        create: true
        no_extra_spaces: true
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010459
        - NIST-800-171-3.1.2
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(b)
        - dconf_gnome_disable_ctrlaltdel_reboot
        - high_severity
        - low_complexity
        - medium_disruption
        - no_reboot_needed
        - unknown_strategy
    
    - name: Prevent user modification of GNOME disablement of Ctrl-Alt-Del
      lineinfile:
        path: /etc/dconf/db/local.d/locks/00-security-settings-lock
        regexp: ^/org/gnome/settings-daemon/plugins/media-keys/logout$
        line: /org/gnome/settings-daemon/plugins/media-keys/logout
        create: true
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010459
        - NIST-800-171-3.1.2
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(b)
        - dconf_gnome_disable_ctrlaltdel_reboot
        - high_severity
        - low_complexity
        - medium_disruption
        - no_reboot_needed
        - unknown_strategy
    
    - name: Dconf Update
      command: dconf update
      when:
        - '"gdm3" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010459
        - NIST-800-171-3.1.2
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(b)
        - dconf_gnome_disable_ctrlaltdel_reboot
        - high_severity
        - low_complexity
        - medium_disruption
        - no_reboot_needed
        - unknown_strategy
    
    - name: Find /etc/sudoers.d/ files
      find:
        paths:
          - /etc/sudoers.d/
      register: sudoers
      tags:
        - DISA-STIG-UBTU-20-010014
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-11
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sudo_require_authentication
    
    - name: Remove lines containing NOPASSWD from sudoers files
      replace:
        regexp: (^(?!#).*[\s]+NOPASSWD[\s]*\:.*$)
        replace: '# \g<1>'
        path: '{{ item.path }}'
        validate: /usr/sbin/visudo -cf %s
      with_items:
        - path: /etc/sudoers
        - '{{ sudoers.files }}'
      tags:
        - DISA-STIG-UBTU-20-010014
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-11
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sudo_require_authentication
    
    - name: Find /etc/sudoers.d/ files
      find:
        paths:
          - /etc/sudoers.d/
      register: sudoers
      tags:
        - DISA-STIG-UBTU-20-010014
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-11
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sudo_require_authentication
    
    - name: Remove lines containing !authenticate from sudoers files
      replace:
        regexp: (^(?!#).*[\s]+\!authenticate.*$)
        replace: '# \g<1>'
        path: '{{ item.path }}'
        validate: /usr/sbin/visudo -cf %s
      with_items:
        - path: /etc/sudoers
        - '{{ sudoers.files }}'
      tags:
        - DISA-STIG-UBTU-20-010014
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-11
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sudo_require_authentication
    
    - name: Ensure YUM Removes Previous Package Versions
      lineinfile:
        dest: /etc/yum.conf
        regexp: ^#?clean_requirements_on_remove
        line: clean_requirements_on_remove=1
        insertafter: \[main\]
        create: true
      tags:
        - DISA-STIG-UBTU-20-010449
        - NIST-800-171-3.4.8
        - NIST-800-53-CM-11(a)
        - NIST-800-53-CM-11(b)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SI-2(6)
        - clean_components_post_updating
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010002
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(b)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_banner_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Enable GNOME3 Login Warning Banner
      ini_file:
        dest: /etc/dconf/db/gdm.d/00-security-settings
        section: org/gnome/login-screen
        option: banner-message-enable
        value: 'true'
        create: true
        no_extra_spaces: true
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010002
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(b)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_banner_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Prevent user modification of GNOME banner-message-enabled
      lineinfile:
        path: /etc/dconf/db/gdm.d/locks/00-security-settings-lock
        regexp: ^/org/gnome/login-screen/banner-message-enable$
        line: /org/gnome/login-screen/banner-message-enable
        create: true
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010002
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(b)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_banner_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Dconf Update
      command: dconf update
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010002
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(b)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_banner_enabled
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    
    - name: Set the GNOME3 Login Warning Banner Text
      file:
        path: /etc/dconf/db/{{ item }}
        owner: root
        group: root
        mode: 493
        state: directory
      with_items:
        - gdm.d
        - gdm.d/locks
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Set the GNOME3 Login Warning Banner Text
      file:
        path: /etc/dconf/db/gdm.d/{{ item }}
        owner: root
        group: root
        mode: 420
        state: touch
      with_items:
        - 00-security-settings
        - locks/00-security-settings-lock
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Set the GNOME3 Login Warning Banner Text
      ini_file:
        dest: /etc/dconf/db/gdm.d/00-security-settings
        section: org/gnome/login-screen
        option: banner-message-text
        value: '''{{ login_banner_text | regex_replace("^\^(.*)\$$", "\1") | regex_replace("^\((.*)\|.*\)$",
          "\1") | regex_replace("\[\\s\\n\]\+"," ") | regex_replace("\(\?:\[\\n\]\+\|\(\?:\\\\n\)\+\)",
          "(n)*") | regex_replace("\\", "") | regex_replace("\(n\)\*", "\\n") }}'''
        create: true
        no_extra_spaces: true
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Prevent user modification of the GNOME3 Login Warning Banner Text
      lineinfile:
        path: /etc/dconf/db/gdm.d/locks/00-security-settings-lock
        regexp: ^/org/gnome/login-screen/banner-message-text$
        line: /org/gnome/login-screen/banner-message-text
        create: true
        state: present
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Dconf Update
      command: dconf update
      when: '"gdm3" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010003
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - dconf_gnome_login_banner_text
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
    
    - name: Ensure libpam-pwquality is installed
      package:
        name: libpam-pwquality
        state: present
      tags:
        - DISA-STIG-UBTU-20-010057
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_pam_pwquality_installed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Check if pam_lastlog.so is set
      lineinfile:
        path: /etc/pam.d/postlogin
        regexp: ^\s*(session)(\s+)[^\s]+(\s+)(pam_lastlog\.so)(\s+)(.*)
        state: absent
      check_mode: true
      changed_when: false
      register: pam_lastlog_exists
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Make sure pam_lastlog.so control is required
      replace:
        path: /etc/pam.d/postlogin
        regexp: ^\s*(session)(\s+)[^\s]+(\s+)(pam_lastlog\.so)(\s+)(.*)
        replace: \1\2required\3\4\5\6
      register: control_update_result
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Add control for pam_lastlog.so module
      lineinfile:
        path: /etc/pam.d/postlogin
        line: session required pam_lastlog.so showfailed
      when:
        - '"libpam-runtime" in ansible_facts.packages'
        - not pam_lastlog_exists.found
      register: add_new_pam_lastlog_control_result
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Add 'showfailed' arg to pam_lastlog.so module
      pamd:
        name: postlogin
        type: session
        control: required
        module_path: pam_lastlog.so
        module_arguments: showfailed
        state: args_present
      when:
        - '"libpam-runtime" in ansible_facts.packages'
        - not add_new_pam_lastlog_control_result.changed
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Remove 'silent' arg for pam_lastlog.so module
      pamd:
        name: postlogin
        type: session
        control: required
        module_path: pam_lastlog.so
        module_arguments: silent
        state: args_absent
      when:
        - '"libpam-runtime" in ansible_facts.packages'
        - not add_new_pam_lastlog_control_result.changed
      tags:
        - CJIS-5.5.2
        - DISA-STIG-UBTU-20-010453
        - NIST-800-53-AC-9(1)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.4
        - configure_strategy
        - display_login_attempts
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010070
        - NIST-800-171-3.5.8
        - NIST-800-53-IA-5(1)(e)
        - NIST-800-53-IA-5(f)
        - PCI-DSS-Req-8.2.5
        - accounts_password_pam_unix_remember
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    
    - name: Do not allow users to reuse recent passwords - system-auth (change)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: ^(password\s+sufficient\s+pam_unix\.so\s.*remember\s*=\s*)(\S+)(.*)$
        replace: \g<1>{{ var_password_pam_unix_remember }}\g<3>
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010070
        - NIST-800-171-3.5.8
        - NIST-800-53-IA-5(1)(e)
        - NIST-800-53-IA-5(f)
        - PCI-DSS-Req-8.2.5
        - accounts_password_pam_unix_remember
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Do not allow users to reuse recent passwords - system-auth (add)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: ^password\s+sufficient\s+pam_unix\.so\s(?!.*remember\s*=\s*).*$
        replace: \g<0> remember={{ var_password_pam_unix_remember }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010070
        - NIST-800-171-3.5.8
        - NIST-800-53-IA-5(1)(e)
        - NIST-800-53-IA-5(f)
        - PCI-DSS-Req-8.2.5
        - accounts_password_pam_unix_remember
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Check to see if pam_tally2.so is configured in /etc/pam.d/common-auth
      shell: grep -e '^\s*auth\s\+required\s\+pam_tally2\.so' /etc/pam.d/common-auth ||
        true
      register: check_pam_tally2_result
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Configure pam_tally2.so module in /etc/pam.d/common-auth
      lineinfile:
        path: /etc/pam.d/common-auth
        line: auth required pam_tally2.so
        state: present
      when: '"pam_tally2" not in check_pam_tally2_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Check to see if 'onerr' parameter is present
      shell: grep -e '^\s*auth\s\+required\s\+pam_tally2\.so.*\sonerr=.*' /etc/pam.d/common-auth
        || true
      register: check_onerr_result
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Make sure pam_tally2.so has 'onerr' parameter set 'fail'
      replace:
        path: /etc/pam.d/common-auth
        regexp: ^(\s*auth\s+required\s+pam_tally2\.so\s+[^\n]*)(onerr=[A-Za-z]+)([^A-Za-z]?.*)
        replace: \1onerr=fail\3
      register: onerr_update_result
      when: '"onerr=" in check_onerr_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Add 'onerr' parameter for pam_tally2.so module in /etc/pam.d/common-auth
      lineinfile:
        path: /etc/pam.d/common-auth
        regexp: ^(\s*auth\s+required\s+pam_tally2\.so)((\s+\S+)*\s*(\\)*$)
        line: \1 onerr=fail\2
        backrefs: true
        state: present
      when: '"onerr=" not in check_onerr_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Check to see if 'deny' parameter is present
      shell: grep -e '^\s*auth\s\+required\s\+pam_tally2\.so.*\sdeny=.*' /etc/pam.d/common-auth
        || true
      register: check_deny_result
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Make sure pam_tally2.so has 'deny' parameter set to less than 4
      replace:
        path: /etc/pam.d/common-auth
        regexp: ^(\s*auth\s+required\s+pam_tally2\.so\s+[^\n]*)deny=([4-9]|[1-9][0-9]+)(\s*.*)
        replace: \1deny=3\3
      when: '"deny=" in check_deny_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Add 'deny' parameter for pam_tally2.so module in /etc/pam.d/common-auth
      lineinfile:
        path: /etc/pam.d/common-auth
        regexp: ^(\s*auth\s+required\s+pam_tally2\.so)((\s+\S+)*\s*(\\)*$)
        line: \1 deny=3\2
        backrefs: true
        state: present
      when: '"deny=" not in check_deny_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Check to see if pam_tally2.so is configured in /etc/pam.d/common-account
      shell: grep -e '^\s*account\s\+required\s\+pam_tally2\.so' /etc/pam.d/common-account
        || true
      register: check_account_pam_tally2_result
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Configure pam_tally2.so module in /etc/pam.d/common-account
      lineinfile:
        path: /etc/pam.d/common-account
        line: account required pam_tally2.so
        state: present
      when: '"pam_tally2" not in check_account_pam_tally2_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010072
        - accounts_passwords_pam_tally2
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010052
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_dcredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable dcredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*dcredit
        line: dcredit = {{ var_password_pam_dcredit }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010052
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_dcredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010056
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_dictcheck
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable dictcheck is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*dictcheck
        line: dictcheck = {{ var_password_pam_dictcheck }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010056
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_dictcheck
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010053
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(b)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_difok
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable difok is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*difok
        line: difok = {{ var_password_pam_difok }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010053
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(b)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_difok
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010057
        - accounts_password_pam_enforcing
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure PAM Enforces Password Requirements - Enforcing
      lineinfile:
        path: /etc/security/pwquality.conf
        create: true
        line: enforcing = 1
        state: present
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010057
        - accounts_password_pam_enforcing
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010051
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_lcredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable lcredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*lcredit
        line: lcredit = {{ var_password_pam_lcredit }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010051
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_lcredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010054
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_minlen
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable minlen is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*minlen
        line: minlen = {{ var_password_pam_minlen }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010054
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_minlen
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010055
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_ocredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable ocredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*ocredit
        line: ocredit = {{ var_password_pam_ocredit }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010055
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - accounts_password_pam_ocredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.5.3
        - DISA-STIG-UBTU-20-010057
        - NIST-800-53-AC-7(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(4)
        - accounts_password_pam_retry
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    
    - name: Set Password Retry Prompts Permitted Per-Session - system-auth (change)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: (^.*\spam_pwquality.so\s.*retry\s*=\s*)(\S+)(.*$)
        replace: \g<1>{{ var_password_pam_retry }}\g<3>
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.3
        - DISA-STIG-UBTU-20-010057
        - NIST-800-53-AC-7(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(4)
        - accounts_password_pam_retry
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set Password Retry Prompts Permitted Per-Session - system-auth (add)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: ^.*\spam_pwquality.so\s(?!.*retry\s*=\s*).*$
        replace: \g<0> retry={{ var_password_pam_retry }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.3
        - DISA-STIG-UBTU-20-010057
        - NIST-800-53-AC-7(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(4)
        - accounts_password_pam_retry
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010050
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_ucredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure PAM variable ucredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*ucredit
        line: ucredit = {{ var_password_pam_ucredit }}
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010050
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(a)
        - NIST-800-53-IA-5(4)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.3
        - accounts_password_pam_ucredit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.2
        - DISA-STIG-UBTU-20-010404
        - NIST-800-171-3.13.11
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(c)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.1
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - set_password_hashing_algorithm_logindefs
    
    
    - name: Set Password Hashing Algorithm in /etc/login.defs
      lineinfile:
        dest: /etc/login.defs
        regexp: ^#?ENCRYPT_METHOD
        line: ENCRYPT_METHOD {{ var_password_hashing_algorithm }}
        state: present
        create: true
      when: '"login" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.2
        - DISA-STIG-UBTU-20-010404
        - NIST-800-171-3.13.11
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(c)
        - NIST-800-53-IA-5(c)
        - PCI-DSS-Req-8.2.1
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - set_password_hashing_algorithm_logindefs
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010460
        - NIST-800-171-3.4.5
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-6(a)
        - disable_ctrlaltdel_burstaction
        - disable_strategy
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
    
    - name: Disable Ctrl-Alt-Del Burst Action
      lineinfile:
        dest: /etc/systemd/system.conf
        state: present
        regexp: ^CtrlAltDelBurstAction
        line: CtrlAltDelBurstAction=none
        create: true
      when: '"systemd" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010460
        - NIST-800-171-3.4.5
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-6(a)
        - disable_ctrlaltdel_burstaction
        - disable_strategy
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
    
    - name: Disable Ctrl-Alt-Del Reboot Activation
      systemd:
        name: ctrl-alt-del.target
        masked: true
        state: stopped
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010460
        - NIST-800-171-3.4.5
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - disable_ctrlaltdel_reboot
        - disable_strategy
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
    
    - name: Ensure vlock is installed
      package:
        name: vlock
        state: present
      tags:
        - DISA-STIG-UBTU-20-010005
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - vlock_installed
    
    - name: Ensure opensc-pkcs11 is installed
      package:
        name: opensc-pkcs11
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010064
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_opensc_installed
    
    - name: Set smartcard packages fact
      set_fact:
        smartcard_packages:
          - pam_pkcs11
          - mozilla-nss
          - mozilla-nss-tools
          - pcsc-ccid
          - pcsc-lite
          - pcsc-tools
          - opensc
          - coolkey
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010063
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - install_smartcard_packages
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure {{ smartcard_packages }} are installed
      package:
        name: '{{ smartcard_packages }}'
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010063
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - install_smartcard_packages
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: package facts
      package_facts: null
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010060
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_ca
    
    - name: Replace 'none' from cert_policy
      replace:
        path: /etc/pam_pkcs11/pam_pkcs11.conf
        regexp: (^\s*cert_policy\s*=\s*)none\s*;(\s*$)
        replace: \g<1>ocsp_on,ca,signature;\g<2>
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '''pam_pkcs11'' in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010060
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_ca
    
    - name: Add 'ca' parameter for cert_policy in /etc/pam_pkcs11/pam_pkcs11.conf
      replace:
        path: /etc/pam_pkcs11/pam_pkcs11.conf
        regexp: (^\s*cert_policy\s*=\s*)(?!.*ca)(.*)
        replace: \g<1>ca,\g<2>
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '''pam_pkcs11'' in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010060
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_ca
    
    - name: package facts
      package_facts: null
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010065
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_cert_checking
    
    - name: Replace 'none' from cert_policy
      replace:
        path: /etc/pam_pkcs11/pam_pkcs11.conf
        regexp: (^\s*cert_policy\s*=\s*)none\s*;(\s*$)
        replace: \g<1>ocsp_on,ca,signature;\g<2>
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '''pam_pkcs11'' in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010065
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_cert_checking
    
    - name: Add 'ocsp_on' parameter for cert_policy in /etc/pam_pkcs11/pam_pkcs11.conf
      replace:
        path: /etc/pam_pkcs11/pam_pkcs11.conf
        regexp: (^\s*cert_policy\s*=\s*)(?!.*ocsp_on)(.*)
        replace: \g<1>ocsp_on,\g<2>
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '''pam_pkcs11'' in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010065
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_configure_cert_checking
    
    - name: Gather list of packages
      package_facts:
        manager: auto
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010033
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_pam_enabled
    
    - name: Check to see if 'pam_pkcs11' module is configured in '/etc/pam.d/common-auth'
      shell: grep -E '^\s*auth\s+\S+\s+pam_pkcs11\.so' /etc/pam.d/common-auth || true
      register: check_pam_pkcs11_module_result
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"pam_pkcs11" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010033
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_pam_enabled
    
    - name: Configure 'pam_pkcs11' module in '/etc/pam.d/common-auth'
      lineinfile:
        path: /etc/pam.d/common-auth
        line: auth sufficient pam_pkcs11.so
        insertafter: ^\s*#
        state: present
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"pam_pkcs11" in ansible_facts.packages'
        - '"pam_pkcs11.so" not in check_pam_pkcs11_module_result.stdout'
      tags:
        - DISA-STIG-UBTU-20-010033
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_pam_enabled
    
    - name: Ensure 'pam_pkcs11' module has 'sufficient' control flag
      lineinfile:
        path: /etc/pam.d/common-auth
        regexp: ^(\s*auth\s+)\S+(\s+pam_pkcs11\.so.*)
        line: \g<1>sufficient\g<2>
        backrefs: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"pam_pkcs11" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010033
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - smartcard_pam_enabled
    
    - name: Verify that 'use_mappers' is set to 'pwent' in PAM
      lineinfile:
        path: /etc/pam_pkcs11/pam_pkcs11.conf
        create: true
        line: use_mappers = pwent
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010006
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
        - verify_use_mappers
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010409
        - NIST-800-171-3.5.6
        - NIST-800-53-AC-2(3)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-4(e)
        - PCI-DSS-Req-8.1.4
        - account_disable_post_pw_expiration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Set Account Expiration Following Inactivity
      lineinfile:
        create: true
        dest: /etc/default/useradd
        regexp: ^INACTIVE
        line: INACTIVE={{ var_account_disable_post_pw_expiration }}
      when: '"login" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010409
        - NIST-800-171-3.5.6
        - NIST-800-53-AC-2(3)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-4(e)
        - PCI-DSS-Req-8.1.4
        - account_disable_post_pw_expiration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1
        - DISA-STIG-UBTU-20-010008
        - NIST-800-171-3.5.6
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(d)
        - NIST-800-53-IA-5(f)
        - PCI-DSS-Req-8.2.4
        - accounts_maximum_age_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Set Password Maximum Age
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^#?PASS_MAX_DAYS
        line: PASS_MAX_DAYS {{ var_accounts_maximum_age_login_defs }}
      when: '"login" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1
        - DISA-STIG-UBTU-20-010008
        - NIST-800-171-3.5.6
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(d)
        - NIST-800-53-IA-5(f)
        - PCI-DSS-Req-8.2.4
        - accounts_maximum_age_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010007
        - NIST-800-171-3.5.8
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(d)
        - NIST-800-53-IA-5(f)
        - accounts_minimum_age_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Set Password Minimum Age
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^#?PASS_MIN_DAYS
        line: PASS_MIN_DAYS {{ var_accounts_minimum_age_login_defs }}
      when: '"login" in ansible_facts.packages'
      tags:
        - CJIS-5.6.2.1.1
        - DISA-STIG-UBTU-20-010007
        - NIST-800-171-3.5.8
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)(d)
        - NIST-800-53-IA-5(f)
        - accounts_minimum_age_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.5.2.2
        - DISA-STIG-UBTU-20-010400
        - NIST-800-53-AC-10
        - NIST-800-53-CM-6(a)
        - accounts_max_concurrent_login_sessions
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Find /etc/security/limits.d files containing maxlogins configuration
      find:
        paths: /etc/security/limits.d
        contains: ^[\s]*\*[\s]+(?:(?:hard)|(?:-))[\s]+maxlogins
        patterns: '*.conf'
      register: maxlogins
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.2.2
        - DISA-STIG-UBTU-20-010400
        - NIST-800-53-AC-10
        - NIST-800-53-CM-6(a)
        - accounts_max_concurrent_login_sessions
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Limit the Number of Concurrent Login Sessions Allowed Per User in files from
        limits.d
      replace:
        dest: '{{ item.path }}'
        regexp: ^#?\*.*maxlogins.*
        replace: '*          hard    maxlogins     {{ var_accounts_max_concurrent_login_sessions
          }}'
      with_items:
        - '{{ maxlogins.files }}'
      when: '"libpam-runtime" in ansible_facts.packages'
      tags:
        - CJIS-5.5.2.2
        - DISA-STIG-UBTU-20-010400
        - NIST-800-53-AC-10
        - NIST-800-53-CM-6(a)
        - accounts_max_concurrent_login_sessions
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Limit the Number of Concurrent Login Sessions Allowed Per User
      lineinfile:
        state: present
        dest: /etc/security/limits.conf
        insertbefore: ^# End of file
        regexp: ^#?\*.*maxlogins
        line: '*          hard    maxlogins     {{ var_accounts_max_concurrent_login_sessions
          }}'
        create: true
      when:
        - '"libpam-runtime" in ansible_facts.packages'
        - maxlogins.matched == 0
      tags:
        - CJIS-5.5.2.2
        - DISA-STIG-UBTU-20-010400
        - NIST-800-53-AC-10
        - NIST-800-53-CM-6(a)
        - accounts_max_concurrent_login_sessions
        - low_complexity
        - low_disruption
        - low_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    
    - name: Set Interactive Session Timeout
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/profile.d/tmout.sh
            create: false
            regexp: ^\s*TMOUT=
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/profile.d/tmout.sh
          lineinfile:
            path: /etc/profile.d/tmout.sh
            create: false
            regexp: ^\s*TMOUT=
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/profile.d/tmout.sh
          lineinfile:
            path: /etc/profile.d/tmout.sh
            create: true
            regexp: ^\s*TMOUT=
            line: TMOUT={{ var_accounts_tmout }}
            state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010013
        - NIST-800-171-3.1.11
        - NIST-800-53-AC-12
        - NIST-800-53-AC-2(5)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SC-10
        - accounts_tmout
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010016
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - accounts_umask_etc_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Ensure the Default UMASK is Set Correctly
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^UMASK
        line: UMASK {{ var_accounts_user_umask }}
      when: '"login" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010016
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - accounts_umask_etc_login_defs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure audispd-plugins is installed
      package:
        name: audispd-plugins
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010216
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_audit-audispd-plugins_installed
    
    - name: Ensure auditd is installed
      package:
        name: auditd
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010182
        - NIST-800-53-AC-7(a)
        - NIST-800-53-AU-12(2)
        - NIST-800-53-AU-14
        - NIST-800-53-AU-2(a)
        - NIST-800-53-AU-7(1)
        - NIST-800-53-AU-7(2)
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_audit_installed
    
    - name: Enable service auditd
      block:
    
        - name: Gather the package facts
          package_facts:
            manager: auto
    
        - name: Enable service auditd
          service:
            name: auditd
            enabled: 'yes'
            state: started
            masked: 'no'
          when:
            - '"auditd" in ansible_facts.packages'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010182
        - NIST-800-171-3.3.1
        - NIST-800-171-3.3.2
        - NIST-800-171-3.3.6
        - NIST-800-53-AC-2(g)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-14(1)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-AU-3
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.1
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_auditd_enabled
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010198
        - NIST-800-171-3.3.1
        - NIST-800-53-AC-17(1)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-14(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IR-5(1)
        - PCI-DSS-Req-10.3
        - grub2_audit_argument
        - low_disruption
        - medium_complexity
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: check audit argument exists
      command: grep 'GRUB_CMDLINE_LINUX.*audit=' /etc/default/grub
      failed_when: false
      register: argcheck
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010198
        - NIST-800-171-3.3.1
        - NIST-800-53-AC-17(1)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-14(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IR-5(1)
        - PCI-DSS-Req-10.3
        - grub2_audit_argument
        - low_disruption
        - medium_complexity
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: replace existing audit argument
      replace:
        path: /etc/default/grub
        regexp: audit=\w+
        replace: audit=1
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'
        - argcheck.rc == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010198
        - NIST-800-171-3.3.1
        - NIST-800-53-AC-17(1)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-14(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IR-5(1)
        - PCI-DSS-Req-10.3
        - grub2_audit_argument
        - low_disruption
        - medium_complexity
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: add audit argument
      replace:
        path: /etc/default/grub
        regexp: (GRUB_CMDLINE_LINUX=.*)"
        replace: \1 audit=1"
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'
        - argcheck.rc != 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010198
        - NIST-800-171-3.3.1
        - NIST-800-53-AC-17(1)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-14(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IR-5(1)
        - PCI-DSS-Req-10.3
        - grub2_audit_argument
        - low_disruption
        - medium_complexity
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: update bootloader menu
      command: /sbin/grubby --update-kernel=ALL --args="audit=1"
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010198
        - NIST-800-171-3.3.1
        - NIST-800-53-AC-17(1)
        - NIST-800-53-AU-10
        - NIST-800-53-AU-14(1)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IR-5(1)
        - PCI-DSS-Req-10.3
        - grub2_audit_argument
        - low_disruption
        - medium_complexity
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /var/log/btmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /var/log/btmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/btmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /var/log/btmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /var/log/btmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/btmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010279
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_btmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /run/utmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/run/utmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /run/utmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /run/utmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /run/utmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/run/utmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /run/utmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /run/utmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010278
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_utmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /var/log/wtmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/wtmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Add watch rule for /var/log/wtmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/wtmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010277
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(iv)
        - audit_rules_session_events_wtmp
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Service facts
      service_facts: null
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Check the rules script being used
      command: grep '^ExecStartPost' /usr/lib/systemd/system/auditd.service
      register: check_rules_scripts_result
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set suid_audit_rules fact
      set_fact:
        suid_audit_rules:
          - -a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid
          - -a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid
          - -a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid
          - -a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Update /etc/audit/rules.d/privileged.rules to audit privileged functions
      lineinfile:
        path: /etc/audit/rules.d/privileged.rules
        line: '{{  item  }}'
        create: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"auditd.service" in ansible_facts.services'
        - '"augenrules" in check_rules_scripts_result.stdout'
      register: augenrules_audit_rules_privilege_function_update_result
      with_items: '{{ suid_audit_rules }}'
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Update Update /etc/audit/audit.rules to audit privileged functions
      lineinfile:
        path: /etc/audit/audit.rules
        line: '{{  item  }}'
        create: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"auditd.service" in ansible_facts.services'
        - '"auditctl" in check_rules_scripts_result.stdout'
      register: auditctl_audit_rules_privilege_function_update_result
      with_items: '{{ suid_audit_rules }}'
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Reload Auditd
      command: /usr/sbin/service auditd reload
      args:
        warn: false
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - (augenrules_audit_rules_privilege_function_update_result.changed or auditctl_audit_rules_privilege_function_update_result.changed)
        - ansible_facts.services["auditd.service"].state == "running"
      tags:
        - DISA-STIG-UBTU-20-010211
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(3)
        - NIST-800-53-AU-7(a)
        - NIST-800-53-AU-7(b)
        - NIST-800-53-AU-8(b)
        - NIST-800-53-CM-5(1)
        - audit_rules_suid_privilege_function
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set architecture for audit group tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_group
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_group.matched is defined and find_group.matched == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_group.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_group.matched is defined and find_group.matched > 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the group rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the group rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010101
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_group
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit gshadow tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_gshadow
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_gshadow.matched is defined and find_gshadow.matched == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_gshadow.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_gshadow.matched is defined and find_gshadow.matched > 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the gshadow rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the gshadow rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010103
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_gshadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit opasswd tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_opasswd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_opasswd.matched is defined and find_opasswd.matched == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_opasswd.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_opasswd.matched is defined and find_opasswd.matched > 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the opasswd rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the opasswd rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010104
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_opasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit passwd tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_passwd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_passwd.matched is defined and find_passwd.matched == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_passwd.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_passwd.matched is defined and find_passwd.matched > 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the passwd rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the passwd rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010100
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit shadow tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_shadow
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_shadow.matched is defined and find_shadow.matched == 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_shadow.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_shadow.matched is defined and find_shadow.matched > 0
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the shadow rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the shadow rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010102
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.5
        - audit_rules_usergroup_modification_shadow
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k logins$
        patterns: '*.rules'
      register: find_sudo_log
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010244
        - audit_sudo_log_events
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/logins.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_sudo_log.matched is defined and find_sudo_log.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010244
        - audit_sudo_log_events
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_sudo_log.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_sudo_log.matched is defined and find_sudo_log.matched > 0
      tags:
        - DISA-STIG-UBTU-20-010244
        - audit_sudo_log_events
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the sudo_log rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/sudo.log -p wa -k logins
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010244
        - audit_sudo_log_events
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the sudo_log rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/sudo.log -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010244
        - audit_sudo_log_events
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Find /etc/audit/ file(s) matching ^audit(\.rules|d\.conf)$
      find:
        paths: /etc/audit/
        patterns: ^audit(\.rules|d\.conf)$
        use_regex: true
      register: files_found
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010135
        - configure_strategy
        - file_groupownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner on /etc/audit/ file(s) matching ^audit(\.rules|d\.conf)$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010135
        - configure_strategy
        - file_groupownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Find /etc/audit/rules.d/ file(s) matching ^.*\.rules$
      find:
        paths: /etc/audit/rules.d/
        patterns: ^.*\.rules$
        use_regex: true
      register: files_found
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010135
        - configure_strategy
        - file_groupownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner on /etc/audit/rules.d/ file(s) matching ^.*\.rules$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010135
        - configure_strategy
        - file_groupownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Find /etc/audit/ file(s) matching ^audit(\.rules|d\.conf)$
      find:
        paths: /etc/audit/
        patterns: ^audit(\.rules|d\.conf)$
        use_regex: true
      register: files_found
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010134
        - configure_strategy
        - file_ownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner on /etc/audit/ file(s) matching ^audit(\.rules|d\.conf)$
      file:
        path: '{{ item.path }}'
        owner: '0'
      with_items:
        - '{{ files_found.files }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010134
        - configure_strategy
        - file_ownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Find /etc/audit/rules.d/ file(s) matching ^.*\.rules$
      find:
        paths: /etc/audit/rules.d/
        patterns: ^.*\.rules$
        use_regex: true
      register: files_found
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010134
        - configure_strategy
        - file_ownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner on /etc/audit/rules.d/ file(s) matching ^.*\.rules$
      file:
        path: '{{ item.path }}'
        owner: '0'
      with_items:
        - '{{ files_found.files }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010134
        - configure_strategy
        - file_ownership_audit_configuration
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set architecture for audit chmod tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010152
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for chmod for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010152
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for chmod for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010152
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit chown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010148
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for chown for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010148
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for chown for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010148
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_chown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fchmod tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010153
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchmod for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010153
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchmod for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010153
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmod
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fchmodat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010154
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmodat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchmodat for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010154
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmodat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchmodat for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat
    
        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010154
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchmodat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fchown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010149
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchown for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010149
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchown for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010149
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fchownat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010150
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchownat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchownat for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010150
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchownat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fchownat for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010150
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fchownat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fremovexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010147
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fremovexattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010147
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fremovexattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010147
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit fsetxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010144
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fsetxattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010144
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for fsetxattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010144
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_fsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit lchown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010151
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lchown for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010151
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lchown for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown
    
        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010151
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lchown
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit lremovexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010146
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lremovexattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010146
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lremovexattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010146
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lremovexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit lsetxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010143
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lsetxattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010143
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for lsetxattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010143
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_lsetxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit removexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010145
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_removexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for removexattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010145
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_removexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for removexattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010145
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_removexattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit setxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010142
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_setxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for setxattr for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010142
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_setxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for setxattr for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr
    
        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F
              key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010142
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.5.5
        - audit_rules_dac_modification_setxattr
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/chacl
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chacl -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chacl -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chacl -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chacl -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010168
        - audit_rules_execution_chacl
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/setfacl
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/setfacl -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/setfacl -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/setfacl -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/setfacl -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010167
        - audit_rules_execution_setfacl
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/chcon
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chcon -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chcon -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chcon -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chcon -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010165
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_execution_chcon
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set architecture for audit rename tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010269
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_rename
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for rename for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010269
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_rename
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for rename for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010269
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_rename
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit renameat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010270
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_renameat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for renameat for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010270
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_renameat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for renameat for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010270
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_renameat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit unlink tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010267
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlink
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for unlink for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010267
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlink
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for unlink for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010267
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlink
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit unlinkat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010268
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlinkat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for unlinkat for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010268
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlinkat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for unlinkat for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir
    
        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k
              |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000
              -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010268
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_file_deletion_events_unlinkat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit creat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010158
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_creat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for creat EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010158
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_creat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for creat EACCES for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010158
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_creat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for creat EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010158
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_creat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for creat EPERM for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010158
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_creat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit ftruncate tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010157
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_ftruncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for ftruncate EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010157
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_ftruncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for ftruncate EACCES for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010157
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_ftruncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for ftruncate EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010157
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_ftruncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for ftruncate EPERM for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010157
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_ftruncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit open tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010155
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010155
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open EACCES for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010155
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010155
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open EPERM for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010155
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit open_by_handle_at tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010160
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open_by_handle_at
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010160
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open_by_handle_at
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86_64
        platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010160
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open_by_handle_at
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010160
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open_by_handle_at
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86_64
        platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010160
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_open_by_handle_at
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit openat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010159
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_openat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for openat EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010159
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_openat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for openat EACCES for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010159
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_openat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for openat EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010159
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_openat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for openat EPERM for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010159
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_openat
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit truncate tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010156
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_truncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for truncate EACCES for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010156
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_truncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for truncate EACCES for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010156
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_truncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for truncate EPERM for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010156
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_truncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for truncate EPERM for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at
    
        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM
              -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010156
        - NIST-800-171-3.1.7
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.1
        - PCI-DSS-Req-10.2.4
        - audit_rules_unsuccessful_file_modification_truncate
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Set architecture for audit delete_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010302
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_delete
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for delete_module for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []
    
        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []
    
        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010302
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_delete
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for delete_module for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []
    
        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []
    
        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010302
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_delete
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set architecture for audit finit_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010180
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_finit
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for finit_module for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010180
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_finit
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for finit_module for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010180
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_finit
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set architecture for audit init_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010179
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_init
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for init_module for x86 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010179
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_init
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Perform remediation of Audit rules for init_module for x86_64 platform
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module
    
        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+((
              -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found
              | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"
      tags:
        - DISA-STIG-UBTU-20-010179
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.7
        - audit_rules_kernel_module_loading_init
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k logins$
        patterns: '*.rules'
      register: find_faillog
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010170
        - audit_rules_login_events_faillog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/logins.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_faillog.matched is defined and find_faillog.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010170
        - audit_rules_login_events_faillog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_faillog.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_faillog.matched is defined and find_faillog.matched > 0
      tags:
        - DISA-STIG-UBTU-20-010170
        - audit_rules_login_events_faillog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the faillog rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/faillog -p wa -k logins
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010170
        - audit_rules_login_events_faillog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the faillog rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/faillog -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010170
        - audit_rules_login_events_faillog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k logins$
        patterns: '*.rules'
      register: find_lastlog
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010171
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_lastlog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/logins.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_lastlog.matched is defined and find_lastlog.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010171
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_lastlog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_lastlog.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_lastlog.matched is defined and find_lastlog.matched > 0
      tags:
        - DISA-STIG-UBTU-20-010171
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_lastlog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the lastlog rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/lastlog -p wa -k logins
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010171
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_lastlog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the lastlog rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/lastlog -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010171
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_lastlog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k logins$
        patterns: '*.rules'
      register: find_tallylog
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010169
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_tallylog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/logins.rules
        as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_tallylog.matched is defined and find_tallylog.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010169
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_tallylog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_tallylog.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_tallylog.matched is defined and find_tallylog.matched > 0
      tags:
        - DISA-STIG-UBTU-20-010169
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_tallylog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the tallylog rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/tallylog -p wa -k logins
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010169
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_tallylog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Inserts/replaces the tallylog rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/tallylog -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010169
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.2.3
        - audit_rules_login_events_tallylog
        - low_complexity
        - low_disruption
        - medium_severity
        - reboot_required
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /sbin/apparmor_parser
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/sbin/apparmor_parser -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/sbin/apparmor_parser -F
              auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/sbin/apparmor_parser -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/sbin/apparmor_parser -F auid>=1000 -F
              auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010166
        - audit_rules_privileged_commands_apparmor_parser
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/chage
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chage -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chage -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chage -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chage -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010175
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_chage
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/chfn
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chfn -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chfn -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chfn -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chfn -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010137
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-3
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_chfn
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/chsh
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chsh -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chsh -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/chsh -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chsh -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010163
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_chsh
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/crontab
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/crontab -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/crontab -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/crontab -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/crontab -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010177
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_crontab
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/gpasswd
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/gpasswd -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/gpasswd -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/gpasswd -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/gpasswd -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010174
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_gpasswd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Check if watch rule for /sbin/modprobe already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/sbin/modprobe\s+-p\s+x(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Search /etc/audit/rules.d for other rules with specified key modules
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)modules$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Use /etc/audit/rules.d/modules.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/modules.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched
          is defined and find_existing_watch_rules_d.matched == 0
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Add watch rule for /sbin/modprobe in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /sbin/modprobe -p x -k modules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Check if watch rule for /sbin/modprobe already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/sbin/modprobe\s+-p\s+x(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Add watch rule for /sbin/modprobe in /etc/audit/audit.rules
      lineinfile:
        line: -w /sbin/modprobe -p x -k modules
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched
          == 0
      tags:
        - DISA-STIG-UBTU-20-010296
        - NIST-800-53-AU-12(a)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-12.1(ii)
        - NIST-800-53-AU-12.1(iv)
        - NIST-800-53-AU-3
        - NIST-800-53-AU-3.1
        - NIST-800-53-MA-4(1)(a)
        - audit_rules_privileged_commands_modprobe
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/mount
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/mount -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/mount -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/mount -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/mount -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010138
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_mount
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/newgrp
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/newgrp -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/newgrp -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/newgrp -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/newgrp -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010164
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_newgrp
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/sbin/pam_timestamp_check
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/sbin/pam_timestamp_check -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/pam_timestamp_check
              -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/sbin/pam_timestamp_check -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/pam_timestamp_check -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010178
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_pam_timestamp_check
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/passwd
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/passwd -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/passwd -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/passwd -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/passwd -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010172
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-2(4)
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_passwd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/ssh-agent
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/ssh-agent -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/ssh-agent -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/ssh-agent -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/ssh-agent -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010140
        - audit_rules_privileged_commands_ssh_agent
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/lib/openssh/ssh-keysign
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/lib/openssh/ssh-keysign -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/lib/openssh/ssh-keysign
              -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/lib/openssh/ssh-keysign -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/lib/openssh/ssh-keysign -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign
              -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010141
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_ssh_keysign
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/su
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/su -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/su -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/su -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/su -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010136
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_su
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/sudo
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/sudo -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/sudo -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/sudo -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/sudo -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F auid>=1000
              -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010161
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_sudo
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/sudoedit
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/sudoedit -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/sudoedit -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/sudoedit -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/sudoedit -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010162
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_sudoedit
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/bin/umount
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/umount -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/umount -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/bin/umount -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/umount -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010139
        - NIST-800-171-3.1.7
        - NIST-800-53-AC-6(9)
        - NIST-800-53-AU-12(c)
        - NIST-800-53-AU-2(d)
        - NIST-800-53-CM-6(a)
        - audit_rules_privileged_commands_umount
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /sbin/unix_update
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/sbin/unix_update -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/sbin/unix_update -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/unix_update -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/sbin/unix_update -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/sbin/unix_update -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/unix_update -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010173
        - audit_rules_privileged_commands_unix_update
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Perform remediation of Audit rules for /usr/sbin/usermod
      block:
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/sbin/usermod -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}
    
        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path
            :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'
    
        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten
            | map(attribute='path') | list }}"
    
        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,
            0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')
            | list }}'
    
        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value')
            | last).key }}"
          when: found_paths | length >= 1
    
        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]
              | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/usermod -F auid>=1000
              -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
    
        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []
    
        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*
              -F path=/usr/sbin/usermod -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'
    
        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"
    
        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') |
            map(attribute='item') | list }}"
    
        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"
    
        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|")
              }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/usermod -F auid>=1000 -F auid!=unset
              (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0
    
        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F
              auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010176
        - audit_rules_privileged_commands_usermod
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    
    - name: Make sure that a remote server is configured for Audispd
      lineinfile:
        path: /etc/audisp/audisp-remote.conf
        line: remote_server = {{ var_audispd_remote_server }}
        regexp: ^\s*remote_server\s*=.*$
        create: true
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010216
        - auditd_audispd_configure_remote_server
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    
    
    - name: Configure auditd Disk Full Action when Disk Space Is Full
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: disk_full_action = {{ var_auditd_disk_full_action }}
        regexp: ^\s*disk_full_action\s*=\s*.*$
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010118
        - NIST-800-53-AU-5(1)
        - NIST-800-53-AU-5(2)
        - NIST-800-53-AU-5(4)
        - NIST-800-53-AU-5(b)
        - NIST-800-53-CM-6(a)
        - auditd_data_disk_full_action
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    
    - name: Configure auditd mail_acct Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: action_mail_acct = {{ var_auditd_action_mail_acct }}
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010117
        - NIST-800-171-3.3.1
        - NIST-800-53-AU-5(2)
        - NIST-800-53-AU-5(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(1)
        - PCI-DSS-Req-10.7.a
        - auditd_data_retention_action_mail_acct
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    
    - name: Configure auditd space_left on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: space_left = {{ var_auditd_space_left }}
        regexp: ^\s*space_left\s*=\s*.*$
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010217
        - NIST-800-53-AU-5(1)
        - NIST-800-53-AU-5(2)
        - NIST-800-53-AU-5(4)
        - NIST-800-53-AU-5(b)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.7
        - auditd_data_retention_space_left
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    
    - name: Configure auditd space_left Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: space_left_action = {{ var_auditd_space_left_action }}
        regexp: ^\s*space_left_action\s*=\s*.*$
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.4.1.1
        - DISA-STIG-UBTU-20-010217
        - NIST-800-171-3.3.1
        - NIST-800-53-AU-5(1)
        - NIST-800-53-AU-5(2)
        - NIST-800-53-AU-5(4)
        - NIST-800-53-AU-5(b)
        - NIST-800-53-CM-6(a)
        - PCI-DSS-Req-10.7
        - auditd_data_retention_space_left_action
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure apparmor is installed
      package:
        name: apparmor
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_apparmor_installed
    
    - name: Start apparmor.service
      systemd:
        name: apparmor.service
        state: started
        enabled: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010439
        - NIST-800-53-AC-3(4)
        - NIST-800-53-AC-6(10)
        - NIST-800-53-AC-6(8)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(2)
        - NIST-800-53-CM-7(5)(b)
        - NIST-800-53-SC-7(21)
        - apparmor_configured
        - medium_severity
    
    - name: Enable service rsyslog
      block:
    
        - name: Gather the package facts
          package_facts:
            manager: auto
    
        - name: Enable service rsyslog
          service:
            name: rsyslog
            enabled: 'yes'
            state: started
            masked: 'no'
          when:
            - '"rsyslog" in ansible_facts.packages'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010432
        - NIST-800-53-AU-4(1)
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_rsyslog_enabled
    
    - name: Check 'UTC' timezone is set
      shell: |
        set -o pipefail
        timedatectl status | grep -i 'Time zone'| grep -iv 'UTC\|GMT' || true
      register: check_tz
      failed_when: check_tz.rc not in [ 0 , 1 ]
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010230
        - ensure_rtc_utc_configuration
        - high_severity
    
    - name: Configure OS to use 'UTC' timezone
      command: timedatectl set-timezone UTC
      become: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - check_tz.rc == 0
      tags:
        - DISA-STIG-UBTU-20-010230
        - ensure_rtc_utc_configuration
        - high_severity
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Set facts'
      set_fact:
        conf_files:
          - /etc/rsyslog.conf
        remote_methods:
          - selector: auth.*
            regexp: ^.*auth\.\*.*$
          - selector: authpriv.*
            regexp: ^.*authpriv\.\*.*$
          - selector: daemon.*
            regexp: ^.*daemon\.\*.*$
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Ensure rsyslog.conf
        exists'
      file:
        path: '{{ conf_files.0 }}'
        state: touch
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Gather conf.d files'
      find:
        patterns:
          - '*.conf'
        paths:
          - /etc/rsyslog.d
      register: rsyslogd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Set conf file(s)'
      set_fact:
        conf_files: '{{ conf_files + [item.path] }}'
      loop: '{{ rsyslogd.files }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - rsyslogd.matched > 0
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Check for existing
        values'
      lineinfile:
        path: '{{ item.1 }}'
        regexp: '{{ item.0.regexp }}'
        state: absent
      check_mode: true
      changed_when: false
      register: remote_method_values
      loop: '{{ remote_methods|product(conf_files)|list }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    - name: 'Ensure remote access methods are monitored in Rsyslog: Configure'
      lineinfile:
        path: /etc/rsyslog.conf
        line: '{{ item.item.0.selector }} /var/log/secure'
        insertafter: ^.*\/var\/log\/secure.*$
        create: true
      loop: '{{ remote_method_values.results }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - item.found == 0
      tags:
        - DISA-STIG-UBTU-20-010403
        - NIST-800-53-AC-17(1)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - rsyslog_remote_access_monitoring
    
    
    
    - name: Ensure sysctl net.ipv4.tcp_syncookies is set
      sysctl:
        name: net.ipv4.tcp_syncookies
        value: '{{ sysctl_net_ipv4_tcp_syncookies_value }}'
        state: present
        reload: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.10.1.1
        - DISA-STIG-UBTU-20-010412
        - NIST-800-171-3.1.20
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - NIST-800-53-SC-5(1)
        - NIST-800-53-SC-5(2)
        - NIST-800-53-SC-5(3)(a)
        - disable_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - reboot_required
        - sysctl_net_ipv4_tcp_syncookies
    
    
    
    - name: Ensure ufw is installed
      package:
        name: ufw
        state: present
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - var_firewall_package == ufw
      tags:
        - DISA-STIG-UBTU-20-010433
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_ufw_installed
    
    
    
    - name: Enable service ufw
      block:
    
        - name: Gather the package facts
          package_facts:
            manager: auto
    
        - name: Enable service ufw
          service:
            name: ufw
            enabled: 'yes'
            state: started
            masked: 'no'
          when:
            - '"ufw" in ansible_facts.packages'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - var_firewall_package == ufw
      tags:
        - DISA-STIG-UBTU-20-010434
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_ufw_enabled
    
    - name: Deactivate Wireless Network Interfaces
      command: nmcli radio wifi off
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010455
        - NIST-800-171-3.1.16
        - NIST-800-53-AC-18(3)
        - NIST-800-53-AC-18(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - NIST-800-53-MP-7
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - unknown_strategy
        - wireless_disable_interfaces
    
    - name: Get all world-writable directories with no sticky bits set
      shell: |
        set -o pipefail
        df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null
      register: dir_output
      tags:
        - DISA-STIG-UBTU-20-010411
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - dir_perms_world_writable_sticky_bits
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: ensure sticky bit is set
      file:
        path: '{{ item }}'
        mode: a+t
      with_items:
        - '{{ dir_output.stdout_lines }}'
      tags:
        - DISA-STIG-UBTU-20-010411
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-6(a)
        - dir_perms_world_writable_sticky_bits
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Find /etc/audit/ file(s)
      find:
        paths: /etc/audit/
        patterns: ^audit(\.rules|d\.conf)$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010133
        - NIST-800-53-AU-12(b)
        - configure_strategy
        - file_permissions_etc_audit_auditd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set permissions for /etc/audit/ file(s)
      file:
        path: '{{ item.path }}'
        mode: '0640'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010133
        - NIST-800-53-AU-12(b)
        - configure_strategy
        - file_permissions_etc_audit_auditd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Find /etc/audit/rules.d/ file(s)
      find:
        paths: /etc/audit/rules.d/
        patterns: ^.*rules$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010133
        - NIST-800-53-AU-12(b)
        - configure_strategy
        - file_permissions_etc_audit_rulesd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Set permissions for /etc/audit/rules.d/ file(s)
      file:
        path: '{{ item.path }}'
        mode: '0640'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010133
        - NIST-800-53-AU-12(b)
        - configure_strategy
        - file_permissions_etc_audit_rulesd
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Find /var/log/ file(s)
      find:
        paths: /var/log/
        patterns: .*
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010416
        - NIST-800-53-SI-11(a)
        - NIST-800-53-SI-11(b)
        - NIST-800-53-SI-11.1(iii)
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - permissions_local_var_log
    
    - name: Set permissions for /var/log/ file(s)
      file:
        path: '{{ item.path }}'
        mode: '0640'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010416
        - NIST-800-53-SI-11(a)
        - NIST-800-53-SI-11(b)
        - NIST-800-53-SI-11.1(iii)
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - permissions_local_var_log
    
    - name: Test for existence /var/log/
      stat:
        path: /var/log/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010417
        - configure_strategy
        - file_groupowner_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 110 on /var/log/
      file:
        path: /var/log/
        group: '110'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010417
        - configure_strategy
        - file_groupowner_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /var/log/syslog
      stat:
        path: /var/log/syslog
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010420
        - configure_strategy
        - file_groupowner_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 4 on /var/log/syslog
      file:
        path: /var/log/syslog
        group: '4'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010420
        - configure_strategy
        - file_groupowner_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /var/log/
      stat:
        path: /var/log/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010418
        - configure_strategy
        - file_owner_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /var/log/
      file:
        path: /var/log/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010418
        - configure_strategy
        - file_owner_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /var/log/syslog
      stat:
        path: /var/log/syslog
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010421
        - configure_strategy
        - file_owner_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 104 on /var/log/syslog
      file:
        path: /var/log/syslog
        owner: '104'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010421
        - configure_strategy
        - file_owner_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /var/log/
      stat:
        path: /var/log/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010419
        - configure_strategy
        - file_permissions_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /var/log/
      file:
        path: /var/log/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010419
        - configure_strategy
        - file_permissions_var_log
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /var/log/syslog
      stat:
        path: /var/log/syslog
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010422
        - configure_strategy
        - file_permissions_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0640 on /var/log/syslog
      file:
        path: /var/log/syslog
        mode: '0640'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010422
        - configure_strategy
        - file_permissions_var_log_syslog
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /bin/
      stat:
        path: /bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /bin/
      file:
        path: /bin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/
      stat:
        path: /sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/
      file:
        path: /sbin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/bin/
      stat:
        path: /usr/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/bin/
      file:
        path: /usr/bin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/sbin/
      stat:
        path: /usr/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/sbin/
      file:
        path: /usr/sbin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/bin/
      stat:
        path: /usr/local/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/local/bin/
      file:
        path: /usr/local/bin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/sbin/
      stat:
        path: /usr/local/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/local/sbin/
      file:
        path: /usr/local/sbin/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010425
        - configure_strategy
        - dir_groupownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /lib/
      stat:
        path: /lib/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /lib/
      file:
        path: /lib/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /lib64/
      stat:
        path: /lib64/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /lib64/
      file:
        path: /lib64/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/lib/
      stat:
        path: /usr/lib/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/lib/
      file:
        path: /usr/lib/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/lib64/
      stat:
        path: /usr/lib64/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /usr/lib64/
      file:
        path: /usr/lib64/
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010431
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_groupownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /bin/
      stat:
        path: /bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /bin/
      file:
        path: /bin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/
      stat:
        path: /sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/
      file:
        path: /sbin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/bin/
      stat:
        path: /usr/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/bin/
      file:
        path: /usr/bin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/sbin/
      stat:
        path: /usr/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/sbin/
      file:
        path: /usr/sbin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/bin/
      stat:
        path: /usr/local/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/local/bin/
      file:
        path: /usr/local/bin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/sbin/
      stat:
        path: /usr/local/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/local/sbin/
      file:
        path: /usr/local/sbin/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010424
        - configure_strategy
        - dir_ownership_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /lib/
      stat:
        path: /lib/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /lib/
      file:
        path: /lib/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /lib64/
      stat:
        path: /lib64/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /lib64/
      file:
        path: /lib64/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/lib/
      stat:
        path: /usr/lib/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/lib/
      file:
        path: /usr/lib/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/lib64/
      stat:
        path: /usr/lib64/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /usr/lib64/
      file:
        path: /usr/lib64/
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010429
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - dir_ownership_library_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /bin/
      stat:
        path: /bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /bin/
      file:
        path: /bin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/
      stat:
        path: /sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/
      file:
        path: /sbin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/bin/
      stat:
        path: /usr/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /usr/bin/
      file:
        path: /usr/bin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/sbin/
      stat:
        path: /usr/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /usr/sbin/
      file:
        path: /usr/sbin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/bin/
      stat:
        path: /usr/local/bin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /usr/local/bin/
      file:
        path: /usr/local/bin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /usr/local/sbin/
      stat:
        path: /usr/local/sbin/
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /usr/local/sbin/
      file:
        path: /usr/local/sbin/
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010423
        - configure_strategy
        - dir_permissions_binary_dirs
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Read list of world and group writable subdirectories in libraries directories
      command: find /lib /lib64 /usr/lib /usr/lib64 -perm /022 -type d
      register: world_writable_library_dirs
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010427
        - NIST-800-53-CM-5
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - dir_permissions_library_dirs
        - high_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Disable world/group writability to library files
      file:
        path: '{{ item }}'
        mode: go-w
      with_items: '{{ world_writable_library_dirs.stdout_lines }}'
      when: world_writable_library_dirs.stdout_lines | length > 0
      tags:
        - DISA-STIG-UBTU-20-010427
        - NIST-800-53-CM-5
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - dir_permissions_library_dirs
        - high_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Test for existence /sbin/auditctl
      stat:
        path: /sbin/auditctl
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/auditctl
      file:
        path: /sbin/auditctl
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/aureport
      stat:
        path: /sbin/aureport
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/aureport
      file:
        path: /sbin/aureport
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/ausearch
      stat:
        path: /sbin/ausearch
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/ausearch
      file:
        path: /sbin/ausearch
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/autrace
      stat:
        path: /sbin/autrace
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/autrace
      file:
        path: /sbin/autrace
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/auditd
      stat:
        path: /sbin/auditd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/auditd
      file:
        path: /sbin/auditd
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/audispd
      stat:
        path: /sbin/audispd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/audispd
      file:
        path: /sbin/audispd
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/augenrules
      stat:
        path: /sbin/augenrules
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure group owner 0 on /sbin/augenrules
      file:
        path: /sbin/augenrules
        group: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010201
        - configure_strategy
        - file_groupownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Retrieve the system command files and set their group ownership to root
      command: find -L {{ item }}  ! -group root -type f -exec chgrp root '{}' \;
      with_items:
        - /bin
        - /sbin
        - /usr/bin
        - /usr/sbin
        - /usr/local/bin
        - /usr/local/sbin
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010458
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - file_groupownership_system_commands_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Test for existence /sbin/auditctl
      stat:
        path: /sbin/auditctl
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/auditctl
      file:
        path: /sbin/auditctl
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/aureport
      stat:
        path: /sbin/aureport
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/aureport
      file:
        path: /sbin/aureport
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/ausearch
      stat:
        path: /sbin/ausearch
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/ausearch
      file:
        path: /sbin/ausearch
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/autrace
      stat:
        path: /sbin/autrace
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/autrace
      file:
        path: /sbin/autrace
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/auditd
      stat:
        path: /sbin/auditd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/auditd
      file:
        path: /sbin/auditd
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/audispd
      stat:
        path: /sbin/audispd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/audispd
      file:
        path: /sbin/audispd
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/augenrules
      stat:
        path: /sbin/augenrules
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure owner 0 on /sbin/augenrules
      file:
        path: /sbin/augenrules
        owner: '0'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010200
        - configure_strategy
        - file_ownership_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Read list of system executables without root ownership
      command: find /bin/ /usr/bin/ /usr/local/bin/ /sbin/ /usr/sbin/ /usr/local/sbin/
        /usr/libexec \! -user root
      register: no_root_system_executables
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010457
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_ownership_binary_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set ownership to root of system executables
      file:
        path: '{{ item }}'
        owner: root
      with_items: '{{ no_root_system_executables.stdout_lines }}'
      when: no_root_system_executables.stdout_lines | length > 0
      tags:
        - DISA-STIG-UBTU-20-010457
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_ownership_binary_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Read list libraries without root ownership
      command: find -L /usr/lib /usr/lib64 /lib /lib64 \! -user root
      register: libraries_not_owned_by_root
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010428
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_ownership_library_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set ownership of system libraries to root
      file:
        path: '{{ item }}'
        owner: root
      with_items: '{{ libraries_not_owned_by_root.stdout_lines }}'
      when: libraries_not_owned_by_root | length > 0
      tags:
        - DISA-STIG-UBTU-20-010428
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_ownership_library_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Test for existence /sbin/auditctl
      stat:
        path: /sbin/auditctl
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/auditctl
      file:
        path: /sbin/auditctl
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/aureport
      stat:
        path: /sbin/aureport
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/aureport
      file:
        path: /sbin/aureport
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/ausearch
      stat:
        path: /sbin/ausearch
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/ausearch
      file:
        path: /sbin/ausearch
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/autrace
      stat:
        path: /sbin/autrace
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/autrace
      file:
        path: /sbin/autrace
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/auditd
      stat:
        path: /sbin/auditd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/auditd
      file:
        path: /sbin/auditd
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/audispd
      stat:
        path: /sbin/audispd
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/audispd
      file:
        path: /sbin/audispd
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Test for existence /sbin/augenrules
      stat:
        path: /sbin/augenrules
      register: file_exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Ensure permission 0755 on /sbin/augenrules
      file:
        path: /sbin/augenrules
        mode: '0755'
      when: file_exists.stat is defined and file_exists.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010199
        - configure_strategy
        - file_permissions_audit_binaries
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
    
    - name: Read list of world and group writable system executables
      command: find /bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin /usr/libexec
        -perm /022 -type f
      register: world_writable_library_files
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010456
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_permissions_binary_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Remove world/group writability of system executables
      file:
        path: '{{ item }}'
        mode: go-w
      with_items: '{{ world_writable_library_files.stdout_lines }}'
      when: world_writable_library_files.stdout_lines | length > 0
      tags:
        - DISA-STIG-UBTU-20-010456
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_permissions_binary_dirs
        - medium_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Read list of world and group writable files in libraries directories
      command: find /lib /lib64 /usr/lib /usr/lib64 -perm /022 -type f
      register: world_writable_library_files
      changed_when: false
      failed_when: false
      check_mode: false
      tags:
        - DISA-STIG-UBTU-20-010426
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_permissions_library_dirs
        - high_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Disable world/group writability to library files
      file:
        path: '{{ item }}'
        mode: go-w
      with_items: '{{ world_writable_library_files.stdout_lines }}'
      when: world_writable_library_files.stdout_lines | length > 0
      tags:
        - DISA-STIG-UBTU-20-010426
        - NIST-800-53-AC-6(1)
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - NIST-800-53-CM-6(a)
        - file_permissions_library_dirs
        - high_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Find /lib/ file(s) matching ^.*$
      find:
        paths: /lib/
        patterns: ^.*$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Ensure group owner on /lib/ file(s) matching ^.*$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Find /lib64/ file(s) matching ^.*$
      find:
        paths: /lib64/
        patterns: ^.*$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Ensure group owner on /lib64/ file(s) matching ^.*$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Find /usr/lib/ file(s) matching ^.*$
      find:
        paths: /usr/lib/
        patterns: ^.*$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Ensure group owner on /usr/lib/ file(s) matching ^.*$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Find /usr/lib64/ file(s) matching ^.*$
      find:
        paths: /usr/lib64/
        patterns: ^.*$
        use_regex: true
      register: files_found
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Ensure group owner on /usr/lib64/ file(s) matching ^.*$
      file:
        path: '{{ item.path }}'
        group: '0'
      with_items:
        - '{{ files_found.files }}'
      tags:
        - DISA-STIG-UBTU-20-010430
        - NIST-800-53-CM-5(6)
        - NIST-800-53-CM-5(6).1
        - configure_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - root_permissions_syslibrary_files
    
    - name: Ensure sysctl kernel.randomize_va_space is set to 2
      sysctl:
        name: kernel.randomize_va_space
        value: '2'
        state: present
        reload: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010448
        - NIST-800-171-3.1.7
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SC-30
        - NIST-800-53-SC-30(2)
        - disable_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - reboot_required
        - sysctl_kernel_randomize_va_space
    
    - name: Disable service kdump
      block:
    
        - name: Gather the service facts
          service_facts: null
    
        - name: Disable service kdump
          systemd:
            name: kdump.service
            enabled: 'no'
            state: stopped
            masked: 'yes'
          when: '"kdump.service" in ansible_facts.services'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010413
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - disable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_kdump_disabled
    
    - name: Unit Socket Exists - kdump.socket
      command: systemctl list-unit-files kdump.socket
      args:
        warn: false
      register: socket_file_exists
      changed_when: false
      ignore_errors: true
      check_mode: false
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010413
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - disable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_kdump_disabled
    
    - name: Disable socket kdump
      systemd:
        name: kdump.socket
        enabled: 'no'
        state: stopped
        masked: 'yes'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"kdump.socket" in socket_file_exists.stdout_lines[1]'
      tags:
        - DISA-STIG-UBTU-20-010413
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - disable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_kdump_disabled
    
    - name: Ensure telnetd is removed
      package:
        name: telnetd
        state: absent
      tags:
        - DISA-STIG-UBTU-20-010405
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - disable_strategy
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
        - package_telnetd_removed
    
    
    
    - name: Ensure chrony is installed
      package:
        name: chrony
        state: present
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - var_time_synchronization_daemon == chrony
      tags:
        - DISA-STIG-UBTU-20-010435
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_chrony_installed
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    
    - name: Check that /etc/ntp.conf exist
      stat:
        path: /etc/ntp.conf
      register: ntp_conf_exist_result
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Update the maxpoll values in /etc/ntp.conf
      lineinfile:
        path: /etc/ntp.conf
        regex: ^(server.*maxpoll) [0-9]+(\s+.*)$
        line: \1 {{ var_time_service_set_maxpoll }}\2
        backrefs: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
        - ntp_conf_exist_result.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set the maxpoll values in /etc/ntp.conf
      lineinfile:
        path: /etc/ntp.conf
        regex: (^server\s+((?!maxpoll).)*)$
        line: \1 maxpoll {{ var_time_service_set_maxpoll }}\n
        backrefs: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
        - ntp_conf_exist_result.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Check that /etc/chrony/chrony.conf exist
      stat:
        path: /etc/chrony/chrony.conf
      register: chrony_conf_exist_result
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Get get conf files from /etc/chrony/chrony.conf
      shell: |
        set -o pipefail
        CHRONY_NAME=/etc/chrony/chrony.conf
        CHRONY_PATH=${CHRONY_NAME%%.*}
        find ${CHRONY_PATH}.* -type f -name '*.conf'
      register: update_chrony_files
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
        - chrony_conf_exist_result.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Update the maxpoll values in /etc/chrony/chrony.conf
      replace:
        path: '{{ item }}'
        regexp: ^((?:server|pool|peer).*maxpoll)[ ]+[0-9]+(.*)$
        replace: \1 {{ var_time_service_set_maxpoll }}\2
      loop: '{{update_chrony_files.stdout_lines|list|flatten|unique}}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
        - chrony_conf_exist_result.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Set the maxpoll values in /etc/chrony/chrony.conf
      lineinfile:
        path: '{{ item }}'
        regex: (^(?:server|pool|peer)\s+((?!maxpoll).)*)$
        line: \1 maxpoll {{ var_time_service_set_maxpoll }}\n
        backrefs: true
      loop: '{{update_chrony_files.stdout_lines|list|flatten|unique}}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"chrony" in ansible_facts.packages or "ntp" in ansible_facts.packages'
        - chrony_conf_exist_result.stat.exists
      tags:
        - DISA-STIG-UBTU-20-010435
        - NIST-800-53-AU-8(1)(b)
        - NIST-800-53-CM-6(a)
        - chronyd_or_ntpd_set_maxpoll
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Synchronize internal information system clocks
      lineinfile:
        path: /etc/chrony/chrony.conf
        create: true
        line: makestep 1 -1
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010436
        - chronyd_sync_clock
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
    
    - name: Ensure rsh-server is removed
      package:
        name: rsh-server
        state: absent
      tags:
        - DISA-STIG-UBTU-20-010406
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - NIST-800-53-IA-5(1)(c)
        - disable_strategy
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
        - package_rsh-server_removed
    
    - name: Ensure openssh-server is installed
      package:
        name: openssh-server
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010042
        - NIST-800-53-CM-6(a)
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - package_openssh-server_installed
    
    - name: Enable service ssh
      block:
    
        - name: Gather the package facts
          package_facts:
            manager: auto
    
        - name: Enable service ssh
          service:
            name: ssh
            enabled: 'yes'
            state: started
            masked: 'no'
          when:
            - '"openssh-server" in ansible_facts.packages'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010042
        - NIST-800-171-3.1.13
        - NIST-800-171-3.13.8
        - NIST-800-171-3.5.4
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SC-8
        - NIST-800-53-SC-8(1)
        - NIST-800-53-SC-8(2)
        - NIST-800-53-SC-8(3)
        - NIST-800-53-SC-8(4)
        - enable_strategy
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - service_sshd_enabled
    
    - name: Disable SSH Access via Empty Passwords
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PermitEmptyPasswords\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PermitEmptyPasswords\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*PermitEmptyPasswords\s+
            line: PermitEmptyPasswords no
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.6
        - DISA-STIG-UBTU-20-010047
        - NIST-800-171-3.1.1
        - NIST-800-171-3.1.5
        - NIST-800-53-AC-17(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - high_severity
        - low_complexity
        - low_disruption
        - no_reboot_needed
        - restrict_strategy
        - sshd_disable_empty_passwords
    
    - name: Disable X11 Forwarding
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*X11Forwarding\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*X11Forwarding\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*X11Forwarding\s+
            line: X11Forwarding no
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010048
        - NIST-800-53-CM-6(b)
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_disable_x11_forwarding
    
    - name: Do Not Allow SSH Environment Options
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PermitUserEnvironment\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PermitUserEnvironment\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*PermitUserEnvironment\s+
            line: PermitUserEnvironment no
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.6
        - DISA-STIG-UBTU-20-010047
        - NIST-800-171-3.1.12
        - NIST-800-53-AC-17(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-7(a)
        - NIST-800-53-CM-7(b)
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_do_not_permit_user_env
    
    - name: Enable PAM
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*UsePAM\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*UsePAM\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*UsePAM\s+
            line: UsePAM yes
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_enable_pam
    
    - name: Enable PubkeyAuthentication
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PubkeyAuthentication\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*PubkeyAuthentication\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*PubkeyAuthentication\s+
            line: PubkeyAuthentication yes
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_enable_pubkey_auth
    
    - name: Enable SSH Warning Banner
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*Banner\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*Banner\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*Banner\s+
            line: Banner /etc/issue.net
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.6
        - DISA-STIG-UBTU-20-010038
        - NIST-800-171-3.1.9
        - NIST-800-53-AC-17(a)
        - NIST-800-53-AC-8(a)
        - NIST-800-53-AC-8(c)
        - NIST-800-53-CM-6(a)
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_enable_warning_banner_net
    
    
    
    - name: Set SSH Idle Timeout Interval
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveInterval\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveInterval\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*ClientAliveInterval\s+
            line: ClientAliveInterval {{ sshd_idle_timeout_value }}
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.6
        - DISA-STIG-UBTU-20-010037
        - NIST-800-171-3.1.11
        - NIST-800-53-AC-12
        - NIST-800-53-AC-17(a)
        - NIST-800-53-AC-17(a)
        - NIST-800-53-AC-2(5)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SC-10
        - PCI-DSS-Req-8.1.8
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_set_idle_timeout
    
    
    
    - name: Set SSH Client Alive Count Max
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveCountMax\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveCountMax\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*ClientAliveCountMax\s+
            line: ClientAliveCountMax {{ var_sshd_set_keepalive }}
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - CJIS-5.5.6
        - DISA-STIG-UBTU-20-010036
        - NIST-800-171-3.1.11
        - NIST-800-53-AC-12
        - NIST-800-53-AC-17(a)
        - NIST-800-53-AC-2(5)
        - NIST-800-53-CM-6(a)
        - NIST-800-53-SC-10
        - PCI-DSS-Req-8.1.8
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_set_keepalive
    
    - name: Configure sshd to use approved ciphers
      lineinfile:
        path: /etc/ssh/sshd_config
        line: Ciphers aes256-ctr,aes192-ctr,aes128-ctr
        state: present
        regexp: ^[\s]*[Cc]iphers[\s]+(aes256-ctr(?=[\w,-@]+|$),?)?(aes192-ctr(?=[\w,-@]+|$),?)?(aes128-ctr(?=[\w,-@]+|$),?)?[\s]*(?:#.*)?$
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010044
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_use_approved_ciphers_ordered_stig
    
    - name: Configure sshd to use approved MACs
      lineinfile:
        path: /etc/ssh/sshd_config
        line: MACs hmac-sha2-512,hmac-sha2-256
        state: present
        regexp: ^[\s]*MACs[\s]+(hmac-sha2-512(?=[\w,-@]+|$),?)?(hmac-sha2-256(?=[\w,-@]+|$),?)?[\s]*(?:#.*)?$
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010043
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_use_approved_macs_ordered_stig
    
    - name: Prevent remote hosts from connecting to the proxy display
      block:
    
        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*X11UseLocalhost\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes
    
        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*X11UseLocalhost\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1
    
        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*X11UseLocalhost\s+
            line: X11UseLocalhost yes
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010049
        - NIST-800-53-CM-6(b)
        - low_complexity
        - low_disruption
        - medium_severity
        - no_reboot_needed
        - restrict_strategy
        - sshd_x11_use_localhost
    
    - name: Gather the package facts
      package_facts:
        manager: auto
      tags:
        - DISA-STIG-UBTU-20-010441
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(13)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - sssd_offline_cred_expiration
    
    - name: Test for domain group
      command: grep '\s*\[domain\/[^]]*]' /etc/sssd/sssd.conf
      register: test_grep_domain
      ignore_errors: true
      changed_when: false
      check_mode: false
      when:
        - '"sssd-common" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010441
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(13)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - sssd_offline_cred_expiration
    
    - name: Add default domain group (if no domain there)
      ini_file:
        path: /etc/sssd/sssd.conf
        section: '{{ item.section }}'
        option: '{{ item.option }}'
        value: '{{ item.value }}'
        create: true
        mode: 384
      with_items:
        - section: sssd
          option: domains
          value: default
        - section: domain/default
          option: id_provider
          value: files
      when:
        - '"sssd-common" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - test_grep_domain.stdout is defined
        - test_grep_domain.stdout | length < 1
      tags:
        - DISA-STIG-UBTU-20-010441
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(13)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - sssd_offline_cred_expiration
    
    - name: Configure SSD to Expire Offline Credentials
      ini_file:
        dest: /etc/sssd/sssd.conf
        section: pam
        option: offline_credentials_expiration
        value: 1
        create: true
        mode: 384
      when:
        - '"sssd-common" in ansible_facts.packages'
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
      tags:
        - DISA-STIG-UBTU-20-010441
        - NIST-800-53-CM-6(a)
        - NIST-800-53-IA-5(13)
        - configure_strategy
        - low_complexity
        - medium_disruption
        - medium_severity
        - no_reboot_needed
        - sssd_offline_cred_expiration
    
